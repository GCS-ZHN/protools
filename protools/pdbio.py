from typing import Iterable, Union, overload
from Bio.PDB.Residue import Residue
from Bio.PDB.Chain import Chain
from Bio.PDB.Model import Model
from Bio.PDB.Structure import Structure
from Bio.PDB.PDBIO import PDBIO
from Bio.PDB import PDBParser

@overload
def save_to_pdb(output_path: str, *entities: Model, remarks: Iterable[str]=None) -> None:
    ...

@overload
def save_to_pdb(output_path: str, *entities: Chain, remarks: Iterable[str]=None) -> None:
    ...

@overload
def save_to_pdb(output_path: str, *entities: Residue, remarks: Iterable[str]=None) -> None:
    ...

def save_to_pdb(output_path: str, *entities: Union[Model, Chain, Residue], remarks: Iterable[str]=None) -> None:
    """
    Save entities to a PDB file.

    Parameters
    ----------
    output_path : str
        Path to the output PDB file.
    entities : Model, Chain, or Residue
        Entities to save.
    remarks : Iterable[str], optional
        Remarks to be written to the PDB file.

    Raises
    ------
    ValueError
        If no entities are provided or if the
        entities are not of the same type.

    TypeError
        If the entities are not of type Model,
        Chain, or Residue.
    """
    if len(entities) == 0:
        raise ValueError("No entities to save")
    
    def _loop_type_check(entities, *allowed_types, allow_none=False):
        for entity in entities:
            if not isinstance(entity, allowed_types):
                if not allow_none or entity is not None:
                    raise ValueError(f"Unsupported type {type(entity)}")
            yield entity
    
    if isinstance(entities[0], Model):
        structure = Structure("pdb")
        for model in _loop_type_check(entities, Model):
            structure.add(model)
        pdb_io = PDBIO()
        pdb_io.set_structure(structure)
        with open(output_path, "w") as fp:
            fp.write("REMARK 220 Generated by Python\n")
            if remarks is not None:
                for remark in remarks:
                    fp.write(f"REMARK 999 {remark}\n")
            pdb_io.save(fp)

    elif isinstance(entities[0], Chain):
        models = [Model("model_0")]
        for chain in _loop_type_check(entities, Chain, allow_none=True):
            if chain is None:
                models.append(Model(f"model_{len(models)}"))
            else:
                models[-1].add(chain)
        save_to_pdb(output_path, *models, remarks=remarks)

    elif isinstance(entities[0], Residue):
        chains = [Chain("A")]
        for residue in _loop_type_check(entities, Residue, allow_none=True):
            if residue is None:
                chain_id = chr(ord(chains[-1].get_id()) + 1)
                if chain_id > "Z":
                    raise ValueError("Too many chains")
                chains.append(Chain(chain_id))
            else:
                chains[-1].add(residue)
        save_to_pdb(output_path, *chains, remarks=remarks)

    else:
        raise TypeError(f"Unsupported type {type(entities[0])}")
